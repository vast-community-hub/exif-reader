Class {
	#name : 'SoSTagFiller',
	#superclass : 'Object',
	#instVars : [
		'tags',
		'file',
		'offset',
		'headerOffset',
		'bigEndian'
	],
	#category : 'SoSExifReaderApp'
}

{ #category : 'IS_generated',
  #vaVisibility : 'private' }
SoSTagFiller class >> _PRAGMA_IS_ [

	"%%PRAGMA DECLARE
	(name: IS_SoSTagFiller isPool: true isConstant: false)
	(pool: IS_SoSTagFiller declarations: (
		(name: IS_instanceInterfaceSpec isConstant: false)
	))"


]

{ #category : 'IS_generated',
  #vaVisibility : 'private' }
SoSTagFiller class >> abtPrimFlushInterfaceSpecCache [

	IS_SoSTagFiller associationsDo: [:poolDictionaryAssoc | poolDictionaryAssoc value: nil].
	super abtPrimFlushInterfaceSpecCache
]

{ #category : 'IS_generated',
  #vaVisibility : 'private' }
SoSTagFiller class >> IS_instanceInterfaceSpec [
	"Private - ** Warning ** This method is generated by VisualAge and should not
	be modified or deleted. This method is responsible for returning a featureSpec
	that describes the implementation of a particular feature of the receiver"

	^IS_SoSTagFiller::IS_instanceInterfaceSpec notNil ifTrue: [IS_SoSTagFiller::IS_instanceInterfaceSpec]
	ifFalse: [IS_SoSTagFiller::IS_instanceInterfaceSpec := AbtInterfaceSpec new]
]

{ #category : 'Not categorized' }
SoSTagFiller class >> newFor: file tags: tags offset: offset bigEndian: bigEndian [

	| o |

	o := self new.
	o
		tags: tags;
		file: file;
		offset: offset;
		bigEndian: bigEndian;
		fillTags.
	^o tagResult
]

{ #category : 'Not categorized' }
SoSTagFiller class >> newFor: file tags: tags offset: offset bigEndian: bigEndian headerOffset: anOffset [

	| o |

	o := self new.
	o
		tags: tags;
		file: file;
		offset: offset;
		bigEndian: bigEndian;
		headerOffset: anOffset;
		fillTags.
	^o tagResult
]

{ #category : 'Calculations' }
SoSTagFiller >> ascii: aTag [

	| result memoryLocation |

	result := OrderedCollection new.
	memoryLocation :=
		((aTag bytes copyFrom: 9 to: 12) asByteArray asInteger: self bigEndian) + self headerOffset.
	aTag count: ((aTag bytes copyFrom: 5 to: 8) asByteArray asInteger: self bigEndian).
	result add: (self getAsciiFromMemoryStartingAt: memoryLocation count: aTag count).
	aTag value: result


]

{ #category : 'Not categorized' }
SoSTagFiller >> bigEndian [

	"Return the value of bigEndian."

	^bigEndian


]

{ #category : 'Not categorized' }
SoSTagFiller >> bigEndian: anObject [

	"Save the value of bigEndian."

	bigEndian := anObject


]

{ #category : 'Calculations' }
SoSTagFiller >> byte: aTag [




]

{ #category : 'Not categorized' }
SoSTagFiller >> doCalculationFor: type on: aTag [

	self perform: type with: aTag


]

{ #category : 'Not categorized' }
SoSTagFiller >> file [

	"Return the value of file."

	^file


]

{ #category : 'Not categorized' }
SoSTagFiller >> file: anObject [

	"Save the value of file."

	file := anObject


]

{ #category : 'Not categorized' }
SoSTagFiller >> fillTags [

	self tags do: [:each | self getResultFor: each]


]

{ #category : 'Not categorized' }
SoSTagFiller >> getAsciiFromMemoryStartingAt: startLocation [

	| nextChar result nextLocation |

	nextChar := 255.
	result := ''.
	nextLocation := startLocation.
	[nextChar = 0] whileFalse: [
		nextChar := self file at: nextLocation.
		(Character value: nextChar) isPrintable
			ifTrue: [result := result , (Character value: nextChar) asString].
		nextLocation := nextLocation + 1].
	^result


]

{ #category : 'Not categorized' }
SoSTagFiller >> getAsciiFromMemoryStartingAt: startLocation count: count [

	| nextChar result nextLocation |

	nextChar := 255.
	result := ''.
	nextLocation := startLocation.
	1 to: count do: [:i |
		nextChar := self file at: nextLocation.
		nextChar = 0 ifFalse: [result := result , (Character value: nextChar) asString].
		nextLocation := nextLocation + 1].
	^result


]

{ #category : 'Not categorized' }
SoSTagFiller >> getDataFromMemoryStartingAt: startLocation forCount: count [

	| result |

	result := self file copyFrom: startLocation to: (startLocation + count).
	^result


]

{ #category : 'Calculations' }
SoSTagFiller >> getFractionFromFileAt: aLocation [

	| num denom |

	num := (self file copyFrom: aLocation to: (aLocation + 3)) asByteArray asInteger: self bigEndian.
	denom :=
		(self file copyFrom: (aLocation + 4) to: (aLocation + 7)) asByteArray
			asInteger: self bigEndian.
	(num = 0 or: [denom = 0]) ifTrue: [^0].
	^num / denom


]

{ #category : 'Not categorized' }
SoSTagFiller >> getMakerNoteFor: aTag [

	| memoryLocation count result |
	result := OrderedCollection new.
	memoryLocation :=
		((aTag bytes copyFrom: 9 to: 12) asByteArray asInteger: self bigEndian) + self headerOffset.
	count := ((aTag bytes copyFrom: 5 to: 8) asByteArray asInteger: self bigEndian).
	result add: (self getDataFromMemoryStartingAt: memoryLocation forCount: count).
	aTag value: result
]

{ #category : 'Calculations' }
SoSTagFiller >> getMultiCountRationalFromFileAt: aLocation count: aCount [

	| num byteCount |

	byteCount := 8.
	num := (self file copyFrom: aLocation to: (aLocation + ((byteCount) * aCount) - 1)) asByteArray.

	^num
]

{ #category : 'Calculations' }
SoSTagFiller >> getRationalFromFileAt: aLocation count: aCount [

	| num  |

	num := self getMultiCountRationalFromFileAt: aLocation count: aCount.

	num = 0 ifTrue: [^0].
	^num
]

{ #category : 'Not categorized' }
SoSTagFiller >> getResultFor: aTag [

	| type |

	aTag isTagError
		ifFalse: [
			type :=
				aTag typeCalculationUsing: self bigEndian for: (aTag actualType asInteger: bigEndian).
			aTag checkDefaultValue
				ifFalse: [self doCalculationFor: type on: aTag]
				ifTrue: [aTag setDefaultValue]]


]

{ #category : 'Not categorized' }
SoSTagFiller >> headerOffset [
	"Return the value of headerOffset."

	^headerOffset
]

{ #category : 'Not categorized' }
SoSTagFiller >> headerOffset: anObject [
	"Save the value of headerOffset."

	headerOffset := anObject
]

{ #category : 'Calculations' }
SoSTagFiller >> long: aTag [

	| result count valueStart value valueOffset |

	count := (aTag bytes copyFrom: 5 to: 8) asByteArray asInteger: self bigEndian.
	result := OrderedCollection new.
	valueStart := 1.
	valueOffset := 4.
	value := (aTag bytes copyFrom: 9 to: 12).
	1 to: count do: [:i |
		result add: (
			(value copyFrom: valueStart to: (valueStart + valueOffset - 1)) asByteArray
				asInteger: self bigEndian).
		valueStart := valueStart + valueOffset].
	aTag value: result


]

{ #category : 'Not categorized' }
SoSTagFiller >> offset [

	"Return the value of offset."

	^offset


]

{ #category : 'Not categorized' }
SoSTagFiller >> offset: anObject [

	"Save the value of offset."

	offset := anObject


]

{ #category : 'Calculations' }
SoSTagFiller >> rational: aTag [

	|  memoryLocation |


	memoryLocation :=
		((aTag bytes copyFrom: 9 to: 12) asByteArray asInteger: self bigEndian) + self headerOffset.
	aTag value: (self getRationalFromFileAt: memoryLocation count: aTag count asNumber)
	"aTag convertFraction ifTrue: [aTag valueAsFloat]"


]

{ #category : 'Calculations' }
SoSTagFiller >> short: aTag [

	((aTag bytes copyFrom: 5 to: 8) asByteArray asInteger: self bigEndian) > 2
		ifTrue: [self shortFromExtraMemory: aTag]
		ifFalse: [self shortFromBytes: aTag]


]

{ #category : 'Not categorized' }
SoSTagFiller >> shortFromBytes: aTag [

	| result count valueStart value valueOffset |

	count := (aTag bytes copyFrom: 5 to: 8) asByteArray asInteger: self bigEndian.
	result := OrderedCollection new.
	valueStart := 1.
	valueOffset := 2.
	value := (aTag bytes copyFrom: 9 to: 12).
	1 to: count do: [:i |
		result add: (
			(value copyFrom: valueStart to: (valueStart + valueOffset - 1)) asByteArray
				asInteger: self bigEndian).
		valueStart := valueStart + valueOffset].
	aTag value: result


]

{ #category : 'Calculations' }
SoSTagFiller >> shortFromExtraMemory: aTag [

	| result count valueStart value valueOffset memStart |

	count := (aTag bytes copyFrom: 5 to: 8) asByteArray asInteger: self bigEndian.
	result := OrderedCollection new.
	valueStart := 1.
	valueOffset := 2.
	memStart := ((aTag bytes copyFrom: 9 to: 12) asByteArray asInteger: self bigEndian) + 13.
	value := (self file copyFrom: memStart to: (memStart + ((count * 2) - 1))) asByteArray.
	1 to: count do: [:i |
		result add: (
			(value copyFrom: valueStart to: (valueStart + valueOffset - 1)) asByteArray
				asInteger: self bigEndian).
		valueStart := valueStart + valueOffset].
	aTag value: result


]

{ #category : 'Calculations' }
SoSTagFiller >> slong: aTag [




]

{ #category : 'Calculations' }
SoSTagFiller >> srational: aTag [

	| memLoc num denom |

	memLoc :=
		((aTag bytes copyFrom: 9 to: 12) asByteArray asInteger: self bigEndian) + self headerOffset.
	num := (self file copyFrom: memLoc to: (memLoc + 3)) alignedFor: self bigEndian.
	num := num int32At: 0.
	denom := (self file copyFrom: (memLoc + 4) to: (memLoc + 7)) alignedFor: self bigEndian.
	denom := denom int32At: 0.
	aTag value: num / denom.
	aTag convertFraction ifTrue: [aTag value: aTag value asFloat]


]

{ #category : 'Not categorized' }
SoSTagFiller >> tagResult [




]

{ #category : 'Not categorized' }
SoSTagFiller >> tags [

	"Return the value of tags."

	^tags


]

{ #category : 'Not categorized' }
SoSTagFiller >> tags: anObject [

	"Save the value of tags."

	tags := anObject


]

{ #category : 'Calculations' }
SoSTagFiller >> undefined: aTag [

	| result memoryLocation count |

	result := OrderedCollection new.
	aTag count = 'Any'
		ifFalse: [
			count := aTag count asNumber.
			count < 5 ifTrue: [aTag getResultFromValue]]
		ifTrue: [
			memoryLocation :=
				((aTag bytes copyFrom: 9 to: 12) asByteArray asInteger: self bigEndian) +
					self headerOffset.
			result add: (self getAsciiFromMemoryStartingAt: memoryLocation).
			aTag value: result]


]
